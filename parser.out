Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    ARRAY
    AS
    BOOLEAN
    BREAK
    CASE
    CLASS
    COMA
    COMENTARIO_LARGO
    COMENTARIO_UNA_LINEA
    CONST
    CONTINUE
    CORCHDER
    CORCHIZQ
    COUNT
    DEFAULT
    DIVISION
    DO
    DOSPUNTOS
    ECHO
    ELSE
    END_SWITCH
    END_WHILE
    EXPONENCIACION
    EXTENDS
    FALSE
    FIN
    FLOAT
    FOR
    FUNCTION
    GLOBAL
    IF
    INICIO
    INTEGER
    LLAVEDER
    LLAVEIZQ
    MAYORQUE
    MENORQUE
    MODULO
    MULTIPLICACION
    NEW
    NULL
    OPERACIONSUM
    OPERALOGICO_MAP
    OPERAMAPA
    OPERAPUT
    OPERASIGNACION
    OPERASIG_ARRAY
    OPERCOMPARACION
    OPERLOGICO_AND
    OPERLOGICO_NOT
    OPERLOGICO_OR
    OPERLOGICO_OREXCLUSIVO
    OPERLOGICO_XOR
    OPERLOG_AND
    PARENDER
    PARENIZQ
    PRINT
    PRIVATE
    PROTECTED
    PUBLIC
    PUNTO
    PUNTOYCOMA
    RESTA
    RETURN
    RSORT
    STATIC
    STRING
    SUMA
    SWITCH
    TRUE
    WHILE

Grammar

Rule 0     S' -> sentencias
Rule 1     sentencias -> valor
Rule 2     valor -> ENTERO
Rule 3     valor -> FLOTANTE
Rule 4     valor -> VARIABLE
Rule 5     valor -> CADENA
Rule 6     valor -> BOOLEANO

Terminals, with rules where they appear

AMPERSAND            : 
ARRAY                : 
AS                   : 
BOOLEAN              : 
BOOLEANO             : 6
BREAK                : 
CADENA               : 5
CASE                 : 
CLASS                : 
COMA                 : 
COMENTARIO_LARGO     : 
COMENTARIO_UNA_LINEA : 
CONST                : 
CONTINUE             : 
CORCHDER             : 
CORCHIZQ             : 
COUNT                : 
DEFAULT              : 
DIVISION             : 
DO                   : 
DOSPUNTOS            : 
ECHO                 : 
ELSE                 : 
END_SWITCH           : 
END_WHILE            : 
ENTERO               : 2
EXPONENCIACION       : 
EXTENDS              : 
FALSE                : 
FIN                  : 
FLOAT                : 
FLOTANTE             : 3
FOR                  : 
FUNCTION             : 
GLOBAL               : 
IF                   : 
INICIO               : 
INTEGER              : 
LLAVEDER             : 
LLAVEIZQ             : 
MAYORQUE             : 
MENORQUE             : 
MODULO               : 
MULTIPLICACION       : 
NEW                  : 
NULL                 : 
OPERACIONSUM         : 
OPERALOGICO_MAP      : 
OPERAMAPA            : 
OPERAPUT             : 
OPERASIGNACION       : 
OPERASIG_ARRAY       : 
OPERCOMPARACION      : 
OPERLOGICO_AND       : 
OPERLOGICO_NOT       : 
OPERLOGICO_OR        : 
OPERLOGICO_OREXCLUSIVO : 
OPERLOGICO_XOR       : 
OPERLOG_AND          : 
PARENDER             : 
PARENIZQ             : 
PRINT                : 
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
PUNTO                : 
PUNTOYCOMA           : 
RESTA                : 
RETURN               : 
RSORT                : 
STATIC               : 
STRING               : 
SUMA                 : 
SWITCH               : 
TRUE                 : 
VARIABLE             : 4
WHILE                : 
error                : 

Nonterminals, with rules where they appear

sentencias           : 0
valor                : 1

Parsing method: LALR

state 0

    (0) S' -> . sentencias
    (1) sentencias -> . valor
    (2) valor -> . ENTERO
    (3) valor -> . FLOTANTE
    (4) valor -> . VARIABLE
    (5) valor -> . CADENA
    (6) valor -> . BOOLEANO

    ENTERO          shift and go to state 3
    FLOTANTE        shift and go to state 4
    VARIABLE        shift and go to state 5
    CADENA          shift and go to state 6
    BOOLEANO        shift and go to state 7

    sentencias                     shift and go to state 1
    valor                          shift and go to state 2

state 1

    (0) S' -> sentencias .



state 2

    (1) sentencias -> valor .

    $end            reduce using rule 1 (sentencias -> valor .)


state 3

    (2) valor -> ENTERO .

    $end            reduce using rule 2 (valor -> ENTERO .)


state 4

    (3) valor -> FLOTANTE .

    $end            reduce using rule 3 (valor -> FLOTANTE .)


state 5

    (4) valor -> VARIABLE .

    $end            reduce using rule 4 (valor -> VARIABLE .)


state 6

    (5) valor -> CADENA .

    $end            reduce using rule 5 (valor -> CADENA .)


state 7

    (6) valor -> BOOLEANO .

    $end            reduce using rule 6 (valor -> BOOLEANO .)

